---
title: C# Basic Concepts
category: WPF - CSharp
author: Daniel Nguyen
tags: ["#WPF"]
date: 2024-07-17
thumbnail: image.jpg
featured: true
---

## What is C#?

C# (pronounced "C-sharp") is a modern, object-oriented programming language developed by Microsoft as part of its .NET initiative

## What are the main features of C#?

1. Object-Oriented Programming (OOP):

C# is built around the principles of object-oriented programming, including classes, inheritance, polymorphism, and encapsulation.

2. Type Safety:

Ensures that all operations are type-checked at compile time, reducing runtime errors and enhancing code reliability.

3. Garbage Collection:

Automatic memory management through garbage collection, which helps in efficiently managing memory and preventing memory leaks.

4. Exception Handling:

Structured exception handling with try, catch, finally, and throw keywords to gracefully handle runtime errors.

5. Language Integrated Query (LINQ):

Provides a powerful, integrated query syntax for querying collections, databases, XML, and more, making data manipulation more intuitive and readable.

6. Asynchronous Programming:

async and await keywords simplify asynchronous programming, allowing developers to write more responsive and scalable applications.

7. Delegates and Events:

Delegates provide a type-safe way to reference methods, and events enable the implementation of the observer pattern, facilitating event-driven programming.

8. Generics:

Allow the creation of type-safe data structures and methods, enabling code reusability and type safety without the performance costs associated with boxing and unboxing.

9. Properties and Indexers:

Properties provide a flexible mechanism to read, write, or compute the values of private fields, and indexers allow objects to be indexed like arrays.

10. Extension Methods:

Enable developers to add new methods to existing types without modifying their source code, enhancing functionality and code readability.

## Explain the difference between value types and reference types in C#.

In C#, the distinction between value types and reference types is fundamental to understanding how data is stored and managed in memory. Here's a detailed explanation of the differences:

**Value Types**

1. Memory Allocation:

- Value types are typically allocated on the stack.
- Each variable of a value type has its own copy of the data.

2. Examples:

- Primitive types: int, double, bool, char, etc.
- Structs: Custom structures defined using the struct keyword.
- Enumerations: Defined using the enum keyword.

3. Lifetime:

- The lifetime of a value type is tied to the scope in which it is declared. When the scope ends, the value type is removed from the stack.

4. Assignment:

When you assign one value type to another, a copy of the data is made. Modifications to one variable do not affect the other.

```C#
int x = 10;
int y = x;  // y gets a copy of x
y = 20;
// x is still 10
```

**Reference Types**

1. Memory Allocation:

- Reference types are allocated on the heap.
- A variable of a reference type stores a reference (or address) to the actual data on the heap.

2. Examples:

- Classes: Defined using the class keyword.
- Arrays: Any array type (e.g., int[], string[]).
- Delegates: Types that refer to methods.
- Strings: The string type in C#.

3. Lifetime:

- The lifetime of a reference type is managed by the .NET garbage collector. When there are no references to an object, the garbage collector can reclaim the memory.

4. Assignment:

- When you assign one reference type to another, only the reference is copied, not the actual data. Both variables then refer to the same object on the heap. Changes to one variable affect the other.

```C#
class MyClass
{
    public int Value;
}

MyClass obj1 = new MyClass();
obj1.Value = 10;
MyClass obj2 = obj1;  // obj2 references the same object as obj1
obj2.Value = 20;
// obj1.Value is now 20, because obj1 and obj2 refer to the same object
```

## What are namespaces in C#?

Namespaces in C# are used to organize code and prevent naming conflicts by grouping related classes, interfaces, enums, structs, and delegates under a unique name. Here are the main features and benefits of using namespaces in C#

### Key Features of Namespaces:

1. Organization:

- Namespaces help organize code by grouping related elements together. This makes the codebase easier to navigate and maintain.

2. Avoiding Naming Conflicts:

- By encapsulating classes and other types within namespaces, you can prevent naming conflicts that might arise if multiple libraries or parts of your code use the same names for different purposes.

3. Hierarchical Structure:

- Namespaces can be nested, allowing for a hierarchical organization. This further refines the organization and grouping of related types.

4. Code Readability:

- Namespaces improve code readability by providing a clear context for where classes and other types are defined.

5. Access Control:

- Namespaces can help control the visibility and access of types. Although C# doesn't have explicit access control on namespaces, organizing code into namespaces helps manage access indirectly.

**Defining and Using Namespaces:**

- Defining a Namespace:

```c#
namespace MyApplication.Utilities
{
    public class Logger
    {
        public void Log(string message)
        {
            // Implementation here
        }
    }
}
```

- Using a Namespace:

```c#
using MyApplication.Utilities;

class Program
{
    static void Main()
    {
        Logger logger = new Logger();
        logger.Log("Hello, World!");
    }
}
```

### Example of Nested Namespaces:

```c#
namespace MyApplication
{
    namespace Data
    {
        public class Database
        {
            // Implementation here
        }
    }

    namespace Services
    {
        public class AuthenticationService
        {
            // Implementation here
        }
    }
}
```

**Aliases and Fully Qualified Names:**

- Using Aliases:

```c#
using Auth = MyApplication.Services.AuthenticationService;

class Program
{
    static void Main()
    {
        Auth authService = new Auth();
        // Use authService here
    }
}
```

- Fully Qualified Names:

```c#
class Program
{
    static void Main()
    {
        MyApplication.Services.AuthenticationService authService = new MyApplication.Services.AuthenticationService();
        // Use authService here
    }
}
```

### Practical Benefits:

1. Code Reusability:

- Namespaces make it easier to reuse code across different projects or modules by avoiding conflicts and making it clear where each type belongs.

2. Modular Development:

- Namespaces support modular development by allowing developers to logically separate different parts of the application, which can then be developed and maintained independently.

3. Third-Party Libraries:

- When using third-party libraries, namespaces prevent clashes with existing code by ensuring that each library's types are contained within their unique namespace.

## What is a nullable type in C#?